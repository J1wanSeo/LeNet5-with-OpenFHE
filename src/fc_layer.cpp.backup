#include "openfhe.h"
#include <iostream>
#include <vector>

using namespace lbcrypto;

int main() {
    // ======================
    // 1. CKKS Context 생성
    // ======================
    CCParams<CryptoContextCKKSRNS> params;
    params.SetRingDim(1 << 16);         // 작게 설정 (빠른 테스트용)
    params.SetScalingModSize(40);
    params.SetBatchSize(4096);
    params.SetMultiplicativeDepth(5);
    params.SetScalingTechnique(FLEXIBLEAUTO);

    CryptoContext<DCRTPoly> cc = GenCryptoContext(params);
    cc->Enable(PKE);
    cc->Enable(LEVELEDSHE);
    cc->Enable(ADVANCEDSHE);

    auto keys = cc->KeyGen();
    cc->EvalMultKeyGen(keys.secretKey);

    // ======================
    // 2. Rotation key 생성
    // ======================
    size_t fc_in_dim = 20;
    size_t fc_out_dim = 5;

    std::vector<int> rotKeys;
    for (size_t k = 1; k < fc_in_dim; k <<= 1)
        rotKeys.push_back(k);
    for (size_t i = 0; i < fc_out_dim; i++)
        rotKeys.push_back(-i);

    cc->EvalAtIndexKeyGen(keys.secretKey, rotKeys);

    // ======================
    // 3. 입력 벡터 (1~20)
    // ======================
    std::vector<double> x(fc_in_dim);
    for (size_t i = 0; i < fc_in_dim; i++)
        x[i] = i + 1;

    auto pt_x = cc->MakeCKKSPackedPlaintext(x);
    auto ct_x = cc->Encrypt(keys.publicKey, pt_x);

    // ======================
    // 4. Weight & Bias 랜덤 생성
    // ======================
    std::vector<double> weights(fc_out_dim * fc_in_dim);
    std::vector<double> bias(fc_out_dim);

    for (size_t i = 0; i < fc_out_dim * fc_in_dim; i++)
        weights[i] = i * 0.1;  // 테스트용 패턴
    for (size_t i = 0; i < fc_out_dim; i++)
        bias[i] = 0.0;  // 테스트용 bias

    // ======================
    // 5. FC 연산
    // ======================
    Ciphertext<DCRTPoly> ct_output;

    for (size_t i = 0; i < fc_out_dim; i++) {
        // 5-1. i번째 neuron weight 추출
        std::vector<double> w_i(weights.begin() + i * fc_in_dim,
                                weights.begin() + (i + 1) * fc_in_dim);

        // 5-2. weight * input
        auto pt_w = cc->MakeCKKSPackedPlaintext(w_i);
        auto ct_mult = cc->EvalMult(ct_x, pt_w);
        ct_mult = cc->Rescale(ct_mult);

        // 5-3. summation (내적)
        for (size_t k = 1; k < fc_in_dim; k <<= 1) {
            auto rotated = cc->EvalRotate(ct_mult, k);
            ct_mult = cc->EvalAdd(ct_mult, rotated);
        }

        // 5-4. bias 추가
        std::vector<double> bias_vec(cc->GetEncodingParams()->GetBatchSize(), bias[i]);
        auto pt_bias = cc->MakeCKKSPackedPlaintext(bias_vec);
        auto ct_neuron = cc->EvalAdd(ct_mult, pt_bias);

        // 5-5. i번째 위치로 shift
        auto ct_shifted = cc->EvalRotate(ct_neuron, -(int)i);
        ct_shifted = cc->Rescale(ct_shifted);

        std::vector<double> mask(cc->GetEncodingParams()->GetBatchSize(), 0.0);
        mask[i] = 1.0;  // i번째 위치만 1
        auto pt_mask = cc->MakeCKKSPackedPlaintext(mask);
        ct_shifted = cc->EvalMult(ct_shifted, pt_mask);
        ct_shifted = cc->Rescale(ct_shifted);
        // 5-6. output 합치기
        ct_output = !i ? ct_shifted : cc->EvalAdd(ct_output, ct_shifted);
    }

    // ======================
    // 6. 복호화 및 결과 출력
    // ======================
    lbcrypto::Plaintext pt;
    cc->Decrypt(keys.secretKey, ct_output, &pt);
    pt->SetLength(fc_out_dim);

    auto result = pt->GetRealPackedValue();
    std::cout << "[FC output]:" << std::endl;
    for (size_t i = 0; i < fc_out_dim; i++) {
        std::cout << "y[" << i << "] = " << result[i] << std::endl;
    }

    return 0;
}
