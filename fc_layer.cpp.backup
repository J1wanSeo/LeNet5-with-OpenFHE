#include "openfhe.h"
#include "conv_bn_module.h"
#include <iostream>
#include <vector>

using namespace lbcrypto;

int main() {
    // ======================
    // 1. CKKS Context 생성
    // ======================
    CCParams<CryptoContextCKKSRNS> params;
    params.SetRingDim(1 << 16);         // 작게 설정 (빠른 테스트용)
    params.SetScalingModSize(40);
    params.SetBatchSize(1 << 15);
    params.SetMultiplicativeDepth(5);
    params.SetScalingTechnique(FLEXIBLEAUTO);

    CryptoContext<DCRTPoly> cc = GenCryptoContext(params);
    cc->Enable(PKE);
    cc->Enable(LEVELEDSHE);
    cc->Enable(ADVANCEDSHE);

    auto keys = cc->KeyGen();
    cc->EvalMultKeyGen(keys.secretKey);

    // ======================
    // 2. Rotation key 생성
    // ======================
    size_t fc_in_dim = 120;
    size_t fc_out_dim = 84;

    std::vector<int> rotKeys;
    for (size_t k = 1; k < fc_in_dim; k <<= 1)
        rotKeys.push_back(k);
    for (size_t i = 0; i < fc_out_dim; i++)
        rotKeys.push_back(-i);

    cc->EvalAtIndexKeyGen(keys.secretKey, rotKeys);

    // ======================
    // 3. 입력 벡터 (1~20)
    // ======================

    std::vector<double> weights(fc_out_dim * fc_in_dim);
    weights= LoadFromTxt("../lenet_weights_epoch(10)/fc1_weight.txt");
    std::vector<double> bias(fc_out_dim);
    bias = LoadFromTxt("../lenet_weights_epoch(10)/fc1_bias.txt");   

    std::vector<double> x(fc_in_dim);
    x = LoadFromTxt("../results/fc1_input.txt");
    std::cout << "x.size() = " << x.size() << std::endl;

    Plaintext pt_x = cc->MakeCKKSPackedPlaintext(x);
    auto ct_x = cc->Encrypt(keys.publicKey, pt_x);

    Plaintext pt_tmp;
    cc->Decrypt(keys.secretKey, ct_x, &pt_tmp);
    pt_tmp->SetLength(fc_in_dim);
    std::cout << "ct_x after decrypt: ";
    for (int i=0; i<fc_in_dim; i++) std::cout << pt_tmp->GetRealPackedValue()[i] << ", ";
    std::cout << std::endl;


    // ======================
    // 5. FC 연산
    // ======================
    Ciphertext<DCRTPoly> ct_output;

    for (size_t i = 0; i < fc_out_dim; i++) {
        // 5-1. i번째 neuron weight 추출
        std::vector<double> w_i(weights.begin() + i * fc_in_dim,
                                weights.begin() + (i + 1) * fc_in_dim);  

        // 5-2. weight * input
        auto pt_w = cc->MakeCKKSPackedPlaintext(w_i);
        auto ct_mult = cc->EvalMult(ct_x, pt_w);
        ct_mult = cc->Rescale(ct_mult);

        // 5-3. summation (내적)
        for (size_t k = 1; k < fc_in_dim; k <<= 1) {
            auto rotated = cc->EvalRotate(ct_mult, k);
            ct_mult = cc->EvalAdd(ct_mult, rotated);
        }

        // 5-4. bias 추가
        std::vector<double> bias_vec(cc->GetEncodingParams()->GetBatchSize(), bias[i]);
        auto pt_bias = cc->MakeCKKSPackedPlaintext(bias_vec);
        auto ct_neuron = cc->EvalAdd(ct_mult, pt_bias);

        // 5-5. i번째 위치로 shift
        auto ct_shifted = cc->EvalRotate(ct_neuron, -(int)i);
        ct_shifted = cc->Rescale(ct_shifted);

        std::vector<double> mask(cc->GetEncodingParams()->GetBatchSize(), 0.0);
        mask[i] = 1.0;  // i번째 위치만 1
        auto pt_mask = cc->MakeCKKSPackedPlaintext(mask);
        ct_shifted = cc->EvalMult(ct_shifted, pt_mask);
        ct_shifted = cc->Rescale(ct_shifted);
        // 5-6. output 합치기
        ct_output = !i ? ct_shifted : cc->EvalAdd(ct_output, ct_shifted);
    }

    //////////////////////////////////////////
    // 4. Decrypt and print results
    //////////////////////////////////////////

    Plaintext pt;
    cc->Decrypt(keys.secretKey, ct_output, &pt);
    pt->SetLength(fc_out_dim);
    auto vec = pt->GetRealPackedValue();

    std::string filename = "../results/fc1_output.txt";
    std::ofstream out(filename);
    out << std::fixed << std::setprecision(8);  

    for (size_t i = 0; i < fc_out_dim; i++) {
        out << vec[i];
        if (i < fc_out_dim - 1) out << ",\n";
    }
    std::cout << "FC result saved to " << filename << std::endl;

    return 0;
}
